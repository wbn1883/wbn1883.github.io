<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wbn1883.github.io/</id>
    <title>皮皮虾的研究基地</title>
    <updated>2022-06-11T06:22:22.649Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wbn1883.github.io/"/>
    <link rel="self" href="https://wbn1883.github.io/atom.xml"/>
    <logo>https://wbn1883.github.io/images/avatar.png</logo>
    <icon>https://wbn1883.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 皮皮虾的研究基地</rights>
    <entry>
        <title type="html"><![CDATA[Anti-aliasing grid 抗锯齿网格]]></title>
        <id>https://wbn1883.github.io/post/anti-aliasing-grid-kang-ju-chi-wang-ge/</id>
        <link href="https://wbn1883.github.io/post/anti-aliasing-grid-kang-ju-chi-wang-ge/">
        </link>
        <updated>2022-04-18T05:07:58.000Z</updated>
        <content type="html"><![CDATA[<p>最近项目需要用到网格，来自fwidth()的ddx ddy抗锯齿线条<br>
<img src="https://wbn1883.github.io//post-images/1650258960665.png" alt="" loading="lazy"><br>
这里贴一下shader:</p>
<pre><code class="language-swift">Shader &quot;Unlit/AAGrid&quot;
{
    Properties
    {
        _GridColour (&quot;Grid Colour&quot;, color) = (1, 1, 1, 1)
        _BaseColour (&quot;Base Colour&quot;, color) = (1, 1, 1, 0)
        _GridSpacing (&quot;Grid Spacing&quot;, float) = 0.1
        _LineThickness (&quot;Line Thickness&quot;, float) = 1
    }
    SubShader
    {
        Tags { &quot;RenderType&quot; = &quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot; }
        LOD 100

        Blend SrcAlpha OneMinusSrcAlpha
        ZWrite Off
        Cull Off
        Offset -1, -1
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;

            struct appdata
            {
                float4 vertex : POSITION;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            CBUFFER_START(UnityPerMaterial)
                fixed4 _GridColour;
                fixed4 _BaseColour;
                float _GridSpacing;
                float _LineThickness;
            CBUFFER_END
            v2f vert(appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = (mul(unity_ObjectToWorld, v.vertex).xz + float2(_GridSpacing * 0.5, _GridSpacing * 0.5)) / _GridSpacing;

                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                float2 wrapped = frac(i.uv) - 0.5f;
                float2 range = abs(wrapped);
                float2 pixelRange = range / fwidth(i.uv);
                float lineWeight = saturate(min(pixelRange.x, pixelRange.y) - _LineThickness);

                return lerp(_GridColour, _BaseColour, lineWeight);
            }
            ENDCG
        }
    }
}
</code></pre>
<hr>
<h3 id="关于fwidth解释"><strong>关于fwidth解释：</strong></h3>
<p>fwidth(v） = abs(ddx(v)) + abs(ddy(v))</p>
<p>ddx(v) = 该像素点右边的v值 - 该像素点的v值</p>
<p>ddy(v) = 该像素点下面的v值 - 该像素点的v值</p>
<p>ddx(v) ddy(v) 在计算出结果的同时，也会存储该像素的v值，这样它周围的像素才能获取到该点的v值</p>
<p>ddx(float3(1,2,3)) = float3(0,0,0) //因为使用该shader的所有像素 输出的记录值都是 float3(1,2,3)那么差值就为float3(0,0,0)</p>
<p>fwidth(Position) 就是计算出 该像素与相邻两个像素的位置的差值</p>
<p>fwidth(Normal) 就是计算出 该像素与相邻两个像素的法线的差值</p>
<p>fwidth(Color) 就是计算出 该像素与相邻两个像素的Color的差值</p>
<p>fwidth(UV) 就是计算出 该像素与相邻两个像素的UV的差值</p>
<p>fwidth ddx ddy 都是有重载形式的。即你输入什么类型的参数 就是什么返回值:</p>
<p>float fwidth(float v); float ddx(float v); float ddy(float v);</p>
<p>float2 fwidth(float2 v); floa2t ddx(float v); float2 ddy(float v);</p>
<p>float3 fwidth(float3 v); float3 ddx(float v); float ddy(float v);<br>
...</p>
]]></content>
    </entry>
</feed>